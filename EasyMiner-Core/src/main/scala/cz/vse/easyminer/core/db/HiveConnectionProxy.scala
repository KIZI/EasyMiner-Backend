package cz.vse.easyminer.core.db

import java.sql.{Array => _, _}
import java.util.Properties
import java.util.concurrent.Executor

import cz.vse.easyminer.core.util.Match
import org.apache.commons.dbcp2.DelegatingStatement
import org.apache.hive.jdbc.HiveStatement

import scala.concurrent.{Future, Promise}
import scala.util.DynamicVariable

class HiveConnectionProxy(conn: Connection) extends Connection {

  private def setAndReturnStatement[T <: Statement](statement: T): T = {
    Match(statement) {
      case hiveStatement: HiveStatement => HiveConnectionProxy.withStatement(hiveStatement)
      case delegatingStatement: DelegatingStatement => setAndReturnStatement(delegatingStatement.getInnermostDelegate)
    }
    statement
  }

  @throws[SQLException]
  def createStatement: Statement = {
    setAndReturnStatement(conn.createStatement)
  }

  @throws[SQLException]
  def prepareStatement(sql: String): PreparedStatement = {
    setAndReturnStatement(conn.prepareStatement(sql))
  }

  @throws[SQLException]
  def prepareCall(sql: String): CallableStatement = {
    setAndReturnStatement(conn.prepareCall(sql))
  }

  @throws[SQLException]
  def nativeSQL(sql: String): String = {
    conn.nativeSQL(sql)
  }

  @throws[SQLException]
  def setAutoCommit(autoCommit: Boolean) {
  }

  @throws[SQLException]
  def getAutoCommit: Boolean = {
    conn.getAutoCommit
  }

  @throws[SQLException]
  def commit() {
    conn.commit()
  }

  @throws[SQLException]
  def rollback() {
    conn.rollback()
  }

  @throws[SQLException]
  def close() {
    conn.close()
  }

  @throws[SQLException]
  def isClosed: Boolean = {
    conn.isClosed
  }

  @throws[SQLException]
  def getMetaData: DatabaseMetaData = {
    conn.getMetaData
  }

  @throws[SQLException]
  def setReadOnly(readOnly: Boolean) {
  }

  @throws[SQLException]
  def isReadOnly: Boolean = {
    conn.isReadOnly
  }

  @throws[SQLException]
  def setCatalog(catalog: String) {
    conn.setCatalog(catalog)
  }

  @throws[SQLException]
  def getCatalog: String = {
    conn.getCatalog
  }

  @throws[SQLException]
  def setTransactionIsolation(level: Int) {
    conn.setTransactionIsolation(level)
  }

  @throws[SQLException]
  def getTransactionIsolation: Int = {
    conn.getTransactionIsolation
  }

  @throws[SQLException]
  def getWarnings: SQLWarning = {
    conn.getWarnings
  }

  @throws[SQLException]
  def clearWarnings() {
    conn.clearWarnings()
  }

  @throws[SQLException]
  def createStatement(resultSetType: Int, resultSetConcurrency: Int): Statement = {
    setAndReturnStatement(conn.createStatement(resultSetType, resultSetConcurrency))
  }

  @throws[SQLException]
  def prepareStatement(sql: String, resultSetType: Int, resultSetConcurrency: Int): PreparedStatement = {
    setAndReturnStatement(conn.prepareStatement(sql, resultSetType, resultSetConcurrency))
  }

  @throws[SQLException]
  def prepareCall(sql: String, resultSetType: Int, resultSetConcurrency: Int): CallableStatement = {
    setAndReturnStatement(conn.prepareCall(sql, resultSetType, resultSetConcurrency))
  }

  @throws[SQLException]
  def getTypeMap: java.util.Map[java.lang.String, java.lang.Class[_]] = {
    conn.getTypeMap
  }

  @throws[SQLException]
  def setTypeMap(map: java.util.Map[java.lang.String, java.lang.Class[_]]) {
    conn.setTypeMap(map)
  }

  @throws[SQLException]
  def setHoldability(holdability: Int) {
    conn.setHoldability(holdability)
  }

  @throws[SQLException]
  def getHoldability: Int = {
    conn.getHoldability
  }

  @throws[SQLException]
  def setSavepoint(): Savepoint = {
    conn.setSavepoint()
  }

  @throws[SQLException]
  def setSavepoint(name: String): Savepoint = {
    conn.setSavepoint(name)
  }

  @throws[SQLException]
  def rollback(savepoint: Savepoint) {
    conn.rollback(savepoint)
  }

  @throws[SQLException]
  def releaseSavepoint(savepoint: Savepoint) {
    conn.releaseSavepoint(savepoint)
  }

  @throws[SQLException]
  def createStatement(resultSetType: Int, resultSetConcurrency: Int, resultSetHoldability: Int): Statement = {
    setAndReturnStatement(conn.createStatement(resultSetType, resultSetConcurrency, resultSetHoldability))
  }

  @throws[SQLException]
  def prepareStatement(sql: String, resultSetType: Int, resultSetConcurrency: Int, resultSetHoldability: Int): PreparedStatement = {
    setAndReturnStatement(conn.prepareStatement(sql, resultSetType, resultSetConcurrency, resultSetHoldability))
  }

  @throws[SQLException]
  def prepareCall(sql: String, resultSetType: Int, resultSetConcurrency: Int, resultSetHoldability: Int): CallableStatement = {
    setAndReturnStatement(conn.prepareCall(sql, resultSetType, resultSetConcurrency, resultSetHoldability))
  }

  @throws[SQLException]
  def prepareStatement(sql: String, autoGeneratedKeys: Int): PreparedStatement = {
    setAndReturnStatement(conn.prepareStatement(sql, autoGeneratedKeys))
  }

  @throws[SQLException]
  def prepareStatement(sql: String, columnIndexes: Array[Int]): PreparedStatement = {
    setAndReturnStatement(conn.prepareStatement(sql, columnIndexes))
  }

  @throws[SQLException]
  def prepareStatement(sql: String, columnNames: Array[String]): PreparedStatement = {
    setAndReturnStatement(conn.prepareStatement(sql, columnNames))
  }

  @throws[SQLException]
  def createClob: Clob = {
    conn.createClob
  }

  @throws[SQLException]
  def createBlob: Blob = {
    conn.createBlob
  }

  @throws[SQLException]
  def createNClob: NClob = {
    conn.createNClob
  }

  @throws[SQLException]
  def createSQLXML: SQLXML = {
    conn.createSQLXML
  }

  @throws[SQLException]
  def isValid(timeout: Int): Boolean = {
    conn.isValid(timeout)
  }

  @throws[SQLClientInfoException]
  def setClientInfo(name: String, value: String) {
    conn.setClientInfo(name, value)
  }

  @throws[SQLClientInfoException]
  def setClientInfo(properties: Properties) {
    conn.setClientInfo(properties)
  }

  @throws[SQLException]
  def getClientInfo(name: String): String = {
    conn.getClientInfo(name)
  }

  @throws[SQLException]
  def getClientInfo: Properties = {
    conn.getClientInfo
  }

  @throws[SQLException]
  def createArrayOf(typeName: String, elements: Array[AnyRef]): java.sql.Array = {
    conn.createArrayOf(typeName, elements)
  }

  @throws[SQLException]
  def createStruct(typeName: String, attributes: Array[AnyRef]): Struct = {
    conn.createStruct(typeName, attributes)
  }

  @throws[SQLException]
  def setSchema(schema: String) {
    conn.setSchema(schema)
  }

  @throws[SQLException]
  def getSchema: String = {
    conn.getSchema
  }

  @throws[SQLException]
  def abort(executor: Executor) {
    conn.abort(executor)
  }

  @throws[SQLException]
  def setNetworkTimeout(executor: Executor, milliseconds: Int) {
    conn.setNetworkTimeout(executor, milliseconds)
  }

  @throws[SQLException]
  def getNetworkTimeout: Int = {
    conn.getNetworkTimeout
  }

  @throws[SQLException]
  def unwrap[T](iface: java.lang.Class[T]): T = {
    conn.unwrap(iface)
  }

  @throws[SQLException]
  def isWrapperFor(iface: java.lang.Class[_]): Boolean = {
    conn.isWrapperFor(iface)
  }

}

object HiveConnectionProxy {

  private val currentQueryState = new DynamicVariable[Option[Promise[HiveStatement]]](None)

  def withQueryState[T](f: Future[HiveStatement] => T) = {
    val promisedHiveStatement = Promise[HiveStatement]()
    try {
      currentQueryState.withValue(Some(promisedHiveStatement))(f(promisedHiveStatement.future))
    } finally {
      if (!promisedHiveStatement.isCompleted) promisedHiveStatement.failure(Exceptions.QueryIsNotControllable)
    }
  }

  def withStatement(hiveStatement: HiveStatement) = Match(currentQueryState.value) {
    case Some(promisedHiveStatement: Promise[HiveStatement]) => promisedHiveStatement.success(hiveStatement)
  }

  object Exceptions {

    object QueryIsNotControllable extends Exception("The query has been done but it is not controllable; it is an invalid call.")

  }

}
